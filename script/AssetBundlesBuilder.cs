using UnityEditor;
using UnityEngine;

using System;
using System.Collections.Generic;
using System.IO;

namespace InJoy.AssetBundles
{
	using Internal;
	
	/// <summary>
	/// Provides with functions to allow to build asset bundles and appropriate player.
	/// </summary>
	public static class Builder
	{
		#region Interface
		
		public const string SOURCE_OF_INDICES          = "Assets/Editor/Conf/AssetBundles";
		public const string TARGET_IN_STREAMING_ASSETS = "Assets/StreamingAssets/AssetBundles";
		
		/// <summary>
		/// Gets or sets the source for assets-to-bundles distribution.
		/// </summary>
		/// <value>
		/// The index. Null means all available indices (default value).
		/// </value>
		public static Index index
		{
			set { m_index = value; }
			get { return m_index; }
		}
		
		/// <summary>
		/// Gets or sets a value indicating whether builder should produce independent asset bundles.
		/// </summary>
		/// <value>
		/// <c>true</c> if asset bundles should be independent; otherwise, <c>false</c>.
		/// </value>
		public static bool BuildIndependentAssetBundles
		{
			set { m_buildIndependentAssetBundles = value; }
			get { return m_buildIndependentAssetBundles; }
		}
		
		/// <summary>
		/// Method to build asset bundle pack.
		/// </summary>
		public enum BuildMethod
		{
			StraightForward,
			SubstitutingOnStubs,
		}
		
		/// <summary>
		/// Gets or sets a value indicating method asset bundles should be produced with.
		/// </summary>
		/// <value>
		/// <c>true</c> if asset bundles should be built carefully; otherwise, <c>false</c>.
		/// </value>
		public static BuildMethod buildMethod
		{
			set { m_buildMethod = value; }
			get { return m_buildMethod; }
		}
		
		/// <summary>
		/// Gets or sets a value indicating whether builder should produce readable index
		/// (for debugging purposes).
		/// </summary>
		/// <value>
		/// <c>true</c> if readable index should be produced; otherwise, <c>false</c>.
		/// </value>
		public static bool BuildReadableIndex
		{
			set { m_buildReadableIndex = value; }
			get { return m_buildReadableIndex; }
		}
		
		/// <summary>
		/// Means, do not generate build tag (it will be null).
		/// </summary>
		public const int BUILDTAG_DO_NOT_STAMP = 0;
		/// <summary>
		/// Means, use build tag, generated by build machines.
		/// On local machines build tag would be null.
		/// </summary>
		public const int BUILDTAG_USE_FROM_BM_ONLY = 10;
		/// <summary>
		/// Means, use build tag, generated by build machines,
		/// or mark build as a local, if it is not possibe.
		/// </summary>
		public const int BUILDTAG_DO_STAMP = 20;
		
		/// <summary>
		/// Gets or sets behaviour how to stamp build tag.
		/// </summary>
		/// <value>
		/// One of the constants with BUILDTAG prefix.
		/// Default value is BUILDTAG_DO_STAMP.
		/// </value>
		public static int BuildTagBehaviour
		{
			set { m_nBuildTagBehaviour = value; }
			get { return m_nBuildTagBehaviour; }
		}
		
		/// <summary>
		/// Asset bundles compression overriding.
		/// </summary>
		public enum AssetBundlesCompressionOverriding
		{
			/// <summary>
			/// Means, use default value from the distribution.
			/// </summary>
			DoNotOverride,
			/// <summary>
			/// Means, every asset bundle should be compressed.
			/// </summary>
			Compressed,
			/// <summary>
			/// Means, every asset bundle should be uncompressed.
			/// </summary>
			Uncompressed,
		}
		
		/// <summary>
		/// Gets or sets overriding for the asset bundles compression.
		/// </summary>
		/// <value>
		/// The asset bundles compression.
		/// </value>
		public static AssetBundlesCompressionOverriding OverrideAssetBundlesCompression
		{
			set { m_compressionOverriding = value; }
			get { return m_compressionOverriding; }
		}
		
		/// <summary>
		/// Excludes the scenes in asset bundles from the specified list.
		/// </summary>
		/// <returns>
		/// The specified list without scenes gotten in asset bundles.
		/// </returns>
		/// <param name='scenes'>
		/// Scenes.
		/// </param>
		public static string[] ExcludeScenesInAssetBundlesFrom(string[] scenes)
		{
			Index[] indices = GetIndexInstances();
			List<string> sceneFilenames = new List<string>(scenes);
			PushItemToDo(1);
			using(ETUtils.ProgressBar pb = new ETUtils.ProgressBar("Excluding scenes got in asset bundles", null))
			{
				int idxScene = 0;
				foreach(string scene in scenes)
				{
					float ptScene = ((float)1) / scenes.Length;
					pb.Progress = ptScene * idxScene;
					int idxIndex = 0;
					foreach(Index index in indices)
					{
						float ptIndex = ptScene / indices.Length;
						pb.Progress = ptScene * idxScene + ptIndex * idxIndex;
						int idxAssetBundle = 0;
						foreach(Index.AssetBundle assetBundle in index.m_assetBundles)
						{
							float ptAssetBundle = ptIndex / index.m_assetBundles.Count;
							pb.Progress = ptScene * idxScene + ptIndex * idxIndex + ptAssetBundle * idxAssetBundle;
							if(assetBundle.m_type == Index.AssetBundle.Type.Scene)
							{
								int idxAsset = 0;
								foreach(Index.AssetBundle.Asset asset in assetBundle.m_assets)
								{
									float ptAsset = ptAssetBundle / assetBundle.m_assets.Count;
									pb.Progress = ptScene * idxScene + ptIndex * idxIndex + ptAssetBundle * idxAssetBundle + ptAsset * idxAsset;
									if(scene.ToLower().Equals(asset.m_filename.ToLower()))
									{
										sceneFilenames.Remove(scene);
									}
									++idxAsset;
								}
							}
							++idxAssetBundle;
						}
						++idxIndex;
					}
					++idxScene;
				}
			}
			PopItemToDo();
			return sceneFilenames.ToArray();
		}
		
		/// <summary>
		/// Builds the player.
		/// </summary>
		/// <param name='outputFilename'>
		/// Output filename with full path and extension.
		/// </param>
		/// <param name='buildTarget'>
		/// Build target.
		/// </param>
		/// <param name='buildOptions'>
		/// Build options.
		/// </param>
		public static void BuildPlayer(string outputFilename, BuildTarget buildTarget, BuildOptions buildOptions)
		{
			using(new Logger.BuildBrackets("Build player \"{0}\"", Path.GetFileNameWithoutExtension(outputFilename)))
			{
				Debug.Log("BuildPlayer - Started");
				
				// check input data
				Assertion.Check(!string.IsNullOrEmpty(outputFilename), "Filename should be specified");
				if(string.IsNullOrEmpty(outputFilename))
				{
					Debug.LogError("BuildPlayer - Wrong input parameters");
					return;
				}
				
				PushItemToDo(1);
				using(ETUtils.ProgressBar pb = new ETUtils.ProgressBar("Building player", null))
				{
					// create required folders
					Debug.Log("BuildPlayer - Creating output folder");
					ETUtils.CreateDirectoryForFile(outputFilename);
					
					// create a list of scenes would be included in the build
					Debug.Log("BuildPlayer - Searching for required for loader application scenes");
					List<string> sceneFilenames = new List<string>(EditorBuildSettings.scenes.Length);
					sceneFilenames.Clear();
					foreach(EditorBuildSettingsScene scene in EditorBuildSettings.scenes)
					{
						if(scene.enabled && File.Exists(scene.path))
						{
							sceneFilenames.Add(scene.path);
						}
					}
					string[] allSceneFilenames = sceneFilenames.ToArray();
					sceneFilenames.Clear();
					sceneFilenames.AddRange(ExcludeScenesInAssetBundlesFrom(allSceneFilenames));
					
					// log, which scenes would be included
					foreach(EditorBuildSettingsScene scene in EditorBuildSettings.scenes)
					{
						bool included = false;
						foreach(string filename in sceneFilenames.ToArray())
						{
							if(filename.ToLower().Equals(scene.path.ToLower()))
							{
								included = true;
								break;
							}
						}
						if(included)
						{
							Debug.Log(string.Format("BuildPlayer -   \"{0}\" - included", scene.path));
						}
						else
						{
							Debug.Log(string.Format("BuildPlayer -   \"{0}\" - skipped", scene.path));
						}
					}
					
					// build player
					if(sceneFilenames.Count > 0)
					{
						Debug.Log("BuildPlayer - Building player...");
						try
						{
							using(new Logger.BuildBrackets("BuildPipeline.BuildPlayer(\"{0}\")", Path.GetFileNameWithoutExtension(outputFilename)))
							{
								BuildPipeline.BuildPlayer(sceneFilenames.ToArray(), outputFilename, buildTarget, buildOptions);
							}
						}
						catch(Exception e)
						{
							Debug.LogWarning(string.Format("BuildPlayer - Caught exception: {0}", e.ToString()));
						}
					}
					else
					{
						ETUtils.MessageBox("Build player", "No scenes have been found for the player. Cannot build anything");
						Debug.LogError("BuildPlayer - No scenes have been found for the player. Cannot build anything");
					}
				}
				PopItemToDo();
				Debug.Log("BuildPlayer - Finished");
			}
		}
		
		/// <summary>
		/// Validates and updates assets in the currently set index.
		/// </summary>
		public static void UpdateAssetBundles()
		{
			using(new Logger.BuildBrackets("Update asset bundles packs"))
			{
				Debug.Log("UpdateAssetBundles - Started");
				using(ETUtils.ProgressBar pb = new ETUtils.ProgressBar("Updating asset bundles", null))
				{
					Index[] indices = GetIndexInstances();
					PushItemToDo(indices.Length);
					for(int idx = 0; idx < indices.Length; ++idx)
					{
						pb.Progress = ((float)idx) / indices.Length;
						UpdateSpecifiedIndex(indices[idx]);
						PopItemToDo(1);
					}
					PopItemToDo();
				}
				Debug.Log("UpdateAssetBundles - Finished");
			}
		}
		
		/// <summary>
		/// Builds the asset bundles.
		/// </summary>
		/// <param name='pathOutput'>
		/// Path output, where asset bundles would be deployed.
		/// If null, then asset bundles would be placed in StreamingAssets folder.
		/// </param>
		/// <param name='buildTarget'>
		/// Build target.
		/// </param>
		/// <param name='buildOptions'>
		/// Build options.
		/// </param>
		public static void BuildAssetBundles(string pathOutput, BuildTarget buildTarget, BuildOptions buildOptions)
		{
			using(new Logger.BuildBrackets("Build asset bundles packs"))
			{
				Debug.Log("BuildAssetBundles - Started");
				
				Assertion.Check(!string.IsNullOrEmpty(pathOutput), "Path should be specified");
				if(string.IsNullOrEmpty(pathOutput))
				{
					Debug.LogError("BuildAssetBundles - Wrong input parameters");
					return;
				}

                uncompressedBundleList.Clear();

				using(ETUtils.ProgressBar pb = new ETUtils.ProgressBar("Building asset bundles", null))
				{
					// create required subfolders
					Debug.Log("BuildAssetBundles - Creating output folder");
					ETUtils.CreateDirectory(pathOutput);
					
					// check, whether assets are valid (exists, moved, deleted)
					// UPD. Currently no need in it. Every bundle would be updated
					// later in BuildSpecifiedIndex
					//UpdateAssetBundles();
					
					// generate asset bundles
					Index[] indices = GetIndexInstances();
					for(int idx = 0; idx < indices.Length; ++idx)
					{
						pb.Progress = ((float)idx) / indices.Length;
						BuildSpecifiedIndex(indices[idx], pathOutput, buildTarget, buildOptions);
					}
				}
				Debug.Log("BuildAssetBundles - Finished");
			}
		}
		
		/// <summary>
		/// For the internal use only.
		/// Gets all available index instances, if index property is null.
		/// Otherwise gets set index.
		/// </summary>
		/// <returns>
		/// The index instances.
		/// </returns>
		public static Index[] GetIndexInstances()
		{
			Index[] ret = new Index[0]{};
			if(index == null)
			{
				using(ETUtils.ProgressBar pb = new ETUtils.ProgressBar("Searching and loading indices", null))
				{
					string[] sourceFiles = Directory.Exists(SOURCE_OF_INDICES) ? Directory.GetFiles(SOURCE_OF_INDICES, "*.xml", SearchOption.TopDirectoryOnly) : new string[]{};
					ret = new Index[sourceFiles.Length];
					PushItemToDo(sourceFiles.Length);
					for(int idxIndex = 0; idxIndex < sourceFiles.Length; ++idxIndex)
					{
						pb.Progress = ((float)idxIndex) / sourceFiles.Length;
						string filledIndexFilename = GetFilledIndexFilename(sourceFiles[idxIndex]);
						if(File.Exists(filledIndexFilename))
						{
							Index filledIndex = null;
							using(FileStream fs = new FileStream(filledIndexFilename, FileMode.Open))
							{
								filledIndex = Index.LoadInstance(fs);
							}
							if((filledIndex != null) && !string.IsNullOrEmpty(filledIndex.m_strippedIndexHash) && (filledIndex.m_strippedIndexHash.Equals(ETUtils.CreateHashForFile(sourceFiles[idxIndex]))))
							{
								ret[idxIndex] = filledIndex;
							}
							else
							{
								ETUtils.DeleteFile(filledIndexFilename);
							}
						}
						if(ret[idxIndex] == null)
						{
							using(FileStream fs = new FileStream(sourceFiles[idxIndex], FileMode.Open))
							{
								ret[idxIndex] = Index.LoadInstance(fs);
							}
						}
						if(ret[idxIndex] != null)
						{
							// to be able to save index later
							ret[idxIndex].m_xmlFilename = sourceFiles[idxIndex];
							
							// to be sync with previous version of the component
							// TODO: on major release this block could be removed
							for(int idxAssetBundle = 0; idxAssetBundle < ret[idxIndex].m_assetBundles.Count; ++idxAssetBundle)
							{
								if(ret[idxIndex].m_assetBundles[idxAssetBundle].m_filename.ToLower().EndsWith(kAssetBundleFileExtension))
								{
									ret[idxIndex].m_assetBundles[idxAssetBundle].m_filename = ret[idxIndex].m_assetBundles[idxAssetBundle].m_filename.Remove(ret[idxIndex].m_assetBundles[idxAssetBundle].m_filename.ToLower().LastIndexOf(kAssetBundleFileExtension));
								}
							}
							
							// to follow diffs up
							string filename = GetPrevFilledIndexFilename(ret[idxIndex].m_xmlFilename);
							if(!string.IsNullOrEmpty(filename))
							{
								if(!ETUtils.IsUnityInBatchMode())
								{
									if(!File.Exists(filename))
									{
										if(File.Exists(filledIndexFilename))
										{
											File.Copy(filledIndexFilename, filename, true);
										}
										else
										{
											// TODO: produce filled index
										}
									}
								}
								if(File.Exists(filename))
								{
									using(FileStream fs = new FileStream(filename, FileMode.Open))
									{
										ret[idxIndex].m_indexToCompareWith = Index.LoadInstance(fs);
										if(ret[idxIndex].m_indexToCompareWith != null)
										{
											// to be able to save index later
											ret[idxIndex].m_indexToCompareWith.m_xmlFilename = filename;
										}
									}
								}
							}
						}

						PopItemToDo(1);
					}
					PopItemToDo();
				}
			}
			else
			{
				ret = new Index[]{index};
			}
			return ret;
		}
		
		/// <summary>
		/// For the internal use only.
		/// </summary>
		public static void UpdateSpecifiedAssetBundle(Index.AssetBundle assetBundle, int[] selectedIds, out bool succeeded, out bool wereAssetsMessedUp)
		{
			const int kStepsToDo = 15; // HACK: hardcoded
			PushItemToDo(kStepsToDo);
			using(ETUtils.ProgressBar pb = new ETUtils.ProgressBar(string.Format("Adding assets to the bundle \"{0}\"", assetBundle.m_filename), null))
			{
				succeeded = true;
				List<string> assets = new List<string>();
				assets.Clear();
				bool canBundleContainAssets = ((assetBundle.m_type == Index.AssetBundle.Type.None) || (assetBundle.m_type == Index.AssetBundle.Type.Asset));
				bool canBundleContainScenes = ((assetBundle.m_type == Index.AssetBundle.Type.None) || (assetBundle.m_type == Index.AssetBundle.Type.Scene));
				bool isAssets = false;
				bool isScenes = false;
				bool warnAboutSceneFilenameLength = false;
				wereAssetsMessedUp = false;
				if(succeeded)
				{
					// skip empty selection
					if((selectedIds != null) && (selectedIds.Length == 0))
					{
						succeeded = false;
						ETUtils.MessageBox("Add selection", "First you should choose assets you're interesting in from the project view tree");
					}
					PopItemToDo(1);
				}
				if(succeeded)
				{
					if(selectedIds != null)
					{
						// find out what assets are in the selection
						pb.Text = "Searching for files in the selection...";
						bool didAskAboutDirectories = false;
						bool shouldDirectoriesBeAdded = false;
						for(int idx = 0; idx < selectedIds.Length; ++idx)
						{
							pb.Progress = ((float)idx) / selectedIds.Length;
							int id = selectedIds[idx];
							string filename = AssetDatabase.GetAssetPath(EditorUtility.InstanceIDToObject(id));
							if(!string.IsNullOrEmpty(filename))
							{
								if(Directory.Exists(filename))
								{
									if(!didAskAboutDirectories)
									{
										shouldDirectoriesBeAdded = ETUtils.DialogBox("Add selection", "Selection contains directories. All assets will be added to the asset bundle. Should directories themselves be followed up for possible updates and so be added as well?");
										didAskAboutDirectories = true;
									}
									if(shouldDirectoriesBeAdded)
									{
										assets.Add(filename);
									}
									assets.AddRange(Directory.GetFiles(filename, "*.*", SearchOption.AllDirectories));
								}
								else
								{
									assets.Add(filename);
								}
							}
						}
					}
					else
					{
						// update assets-directories (only adds)
						pb.Text = "Updating assets from directories...";
						for(int idx = 0; idx < assetBundle.m_assets.Count; ++idx)
						{
							pb.Progress = ((float)idx) / assetBundle.m_assets.Count;
							string filename = assetBundle.m_assets[idx].m_filename;
							if(Directory.Exists(filename))
							{
								assets.AddRange(Directory.GetFiles(filename, "*.*", SearchOption.AllDirectories));
							}
						}
					}
					PopItemToDo(1);
				}
				if(succeeded)
				{
					// skip empty list
					if(assets.Count == 0)
					{
						succeeded = false;
						if(selectedIds != null)
						{
							ETUtils.MessageBox("Add selection", "No assets have been found in the selection. Nothing to add");
						}
					}
					PopItemToDo(1);
				}
				if(succeeded)
				{
					// filenames should not contain both kinds of slashes
					pb.Text = "Validating collected names...";
					for(int idx = 0; idx < assets.Count; ++idx)
					{
						pb.Progress = ((float)idx) / assets.Count;
						assets[idx] = assets[idx].Replace('\\', '/');
					}
					PopItemToDo(1);
				}
				if(succeeded)
				{
					// remove non-assets files and detect scenes
					pb.Text = "Searching for assets in the files...";
					bool warnedAboutAssets = (selectedIds == null);
					bool warnedAboutScenes = (selectedIds == null);
					int idx = 0;
					while(idx < assets.Count)
					{
						pb.Progress = ((float)idx) / assets.Count;
						string str = assets[idx].ToLower();
						if (str.Contains("/editor/") ||
							str.EndsWith("/editor") ||
							str.Contains("/resources/") ||
							str.EndsWith("/resources") ||
							str.Contains("/streamingassets/") ||
							str.EndsWith("/streamingassets") ||
						    str.EndsWith(".cs") ||
							str.EndsWith(".rsp") ||
							str.EndsWith(".meta") ||
							str.Contains("/."))
						{
							assets.RemoveAt(idx);
						}
						else
						{
							bool isFileScene = str.EndsWith(".unity");
							bool isFileAsset = !isFileScene;
							bool noAssetsCheckFailed = (!canBundleContainAssets && isFileAsset);
							bool noScenesCheckFailed = (!canBundleContainScenes && isFileScene);
							if(noAssetsCheckFailed || noScenesCheckFailed)
							{
								if(noAssetsCheckFailed && !warnedAboutAssets)
								{
									ETUtils.MessageBox("Add selection", "This asset bundle isn't allowed to contain assets. They'll be excluded from the selection automatically");
									warnedAboutAssets = true;
								}
								if(noScenesCheckFailed && !warnedAboutScenes)
								{
									ETUtils.MessageBox("Add selection", "This asset bundle isn't allowed to contain scenes. They'll be excluded from the selection automatically");
									warnedAboutScenes = true;
								}
								assets.RemoveAt(idx);
							}
							else
							{
								isAssets |= isFileAsset;
								isScenes |= isFileScene;
								++idx;
							}
						}
					}
				}
				if(succeeded)
				{
					// skip empty list
					if(assets.Count == 0)
					{
						succeeded = false;
						if(selectedIds != null)
						{
							ETUtils.MessageBox("Add selection", "No assets have been found in the selection. Nothing to add");
						}
					}
					PopItemToDo(1);
				}
				if(succeeded)
				{
					// both assets and scenes are not allowed, choose only one option
					if(canBundleContainAssets && isAssets && canBundleContainScenes && isScenes)
					{
						if(ETUtils.DialogBox("Add selection", "You're trying to put both assets and scenes in the same asset bundle. It isn't allowed. What do you want to add to the bundle?", "Assets only", "Scenes only"))
						{
							// add only assets
							canBundleContainScenes = false;
						}
						else
						{
							// add only scenes
							canBundleContainAssets = false;
						}
					}
					PopItemToDo(1);
				}
				if(succeeded)
				{
					if((!canBundleContainAssets && isAssets) || (!canBundleContainScenes && isScenes))
					{
						// remove disallowed ones
						pb.Text = "Filtering out assets...";
						int idx = 0;
						while(idx < assets.Count)
						{
							pb.Progress = ((float)idx)/assets.Count;
							string str = assets[idx].ToLower();
							bool isFileScene = str.EndsWith(".unity");
							bool isFileAsset = !isFileScene;
							bool noAssetsCheckFailed = (!canBundleContainAssets && isFileAsset);
							bool noScenesCheckFailed = (!canBundleContainScenes && isFileScene);
							if(noAssetsCheckFailed || noScenesCheckFailed)
							{
								assets.RemoveAt(idx);
							}
							else
							{
								++idx;
							}
						}
					}
					PopItemToDo(1);
				}
				if(succeeded)
				{
					// remove duplicates
					pb.Text = "Checking for duplicates...";
					for(int i = 0; i < assetBundle.m_assets.Count; ++i)
					{
						string dstAsset = assetBundle.m_assets[i].m_filename.Replace('\\', '/').ToLower();
						int j = 0;
						while(j < assets.Count)
						{
							pb.Progress = ((float)(i * assets.Count + j)) / (assetBundle.m_assets.Count * assets.Count);
							string srcAsset = assets[j].ToLower();
							if(srcAsset.Equals(dstAsset))
							{
								assets.RemoveAt(j);
							}
							else
							{
								++j;
							}
						}
					}
					// TODO: should assets duplicated by ones from previously built bundles be removed?
					PopItemToDo(1);
				}
				if(succeeded)
				{
					// now empty list means all assets are already added
					if(assets.Count == 0)
					{
						succeeded = false;
						if(selectedIds != null)
						{
							ETUtils.MessageBox("Add selection", "All selected assets are already in the asset bundle. Nothing to add");
						}
					}
					PopItemToDo(1);
				}
				if(succeeded)
				{
					// add assets to the asset bundle (finally)
					pb.Text = "Adding assets to the asset bundle...";
					for(int idx = 0; idx < assets.Count; ++idx)
					{
						pb.Progress = ((float)idx) / assets.Count;
						Index.AssetBundle.Asset asset = new Index.AssetBundle.Asset();
						asset.m_filename = assets[idx];
						asset.m_guid     = AssetDatabase.AssetPathToGUID(asset.m_filename);
						asset.m_hash     = File.Exists(asset.m_filename) ? ETUtils.CreateHashForAsset(asset.m_filename) : null;
						assetBundle.m_assets.Add(asset);
						if(!ETUtils.IsAssetFilenameValid(asset.m_filename))
						{
							warnAboutSceneFilenameLength = true;
						}
					}
					if(assetBundle.m_type == Index.AssetBundle.Type.None)
					{
						if(canBundleContainAssets && isAssets)
						{
							assetBundle.m_type = Index.AssetBundle.Type.Asset;
						}
						if(canBundleContainScenes && isScenes)
						{
							assetBundle.m_type = Index.AssetBundle.Type.Scene;
						}
						// commented assert out, because empty directory could be added
						//Assertion.Check(assetBundle.m_type != AssetBundles.Index.AssetBundle.Type.None);
					}
					PopItemToDo(1);
				}
				if(succeeded)
				{
					// sort assets out
					pb.Text = "Sorting assets out...";
					// TODO: update from O(n^2) to O(n*log2(n))
					for(int i = 0; i < assetBundle.m_assets.Count; ++i)
					{
						int idxFirst = i;
						for(int j = i + 1; j < assetBundle.m_assets.Count; ++j)
						{
							pb.Progress = ((float)i) / assetBundle.m_assets.Count + ((float)j) / assetBundle.m_assets.Count / assetBundle.m_assets.Count;
							string target = assetBundle.m_assets[idxFirst].m_filename;
							string candid = assetBundle.m_assets[j].m_filename;
							if(Directory.Exists(target))
							{
								if(Directory.Exists(candid))
								{
									if(candid.CompareTo(target) < 0)
									{
										idxFirst = j;
									}
								}
							}
							else
							{
								if(Directory.Exists(candid))
								{
									// first goes directories
									idxFirst = j;
								}
								else
								{
									int cmpDirectories = Path.GetDirectoryName(candid).CompareTo(Path.GetDirectoryName(target));
									cmpDirectories = 0; // do not differ assets by directories
									if(cmpDirectories < 0)
									{
										// second goes files sorted by directories
										idxFirst = j;
									}
									else if(cmpDirectories == 0)
									{
										int cmpExtensions = Path.GetExtension(candid.ToLower()).CompareTo(Path.GetExtension(target.ToLower()));
										if(cmpExtensions < 0)
										{
											// third goes files sorted by extensions
											idxFirst = j;
										}
										else if(cmpExtensions == 0)
										{
											int cmpFilename = Path.GetFileName(candid).CompareTo(Path.GetFileName(target));
											if(cmpFilename < 0)
											{
												// fourth goes files sorted by filenames
												idxFirst = j;
											}
											else if(cmpFilename == 0)
											{
												cmpFilename = candid.CompareTo(target);
												if(cmpFilename < 0)
												{
													// last goes files sorted by their full filename
													idxFirst = j;
												}
											}
										}
									}
								}
							}
						}
						if(idxFirst != i)
						{
							Index.AssetBundle.Asset temp = assetBundle.m_assets[i];
							assetBundle.m_assets[i] = assetBundle.m_assets[idxFirst];
							assetBundle.m_assets[idxFirst] = temp;
							wereAssetsMessedUp = true;
						}
					}
					PopItemToDo(1);
				}
				if(succeeded)
				{
					// remove included subdirectories
					pb.Text = "Filtering assets out...";
					for(int i = 0; i < assetBundle.m_assets.Count; ++i)
					{
						for(int j = i + 1; j < assetBundle.m_assets.Count; ++j)
						{
							pb.Progress = ((float)i) / assetBundle.m_assets.Count + ((float)j) / assetBundle.m_assets.Count / assetBundle.m_assets.Count;
							string target = assetBundle.m_assets[i].m_filename;
							string candid = assetBundle.m_assets[j].m_filename;
							if(Directory.Exists(target))
							{
								if(Directory.Exists(candid))
								{
									if(candid.IndexOf(target) == 0)
									{
										assetBundle.m_assets.RemoveAt(j);
										--j;
										wereAssetsMessedUp = true;
									}
									if(target.IndexOf(candid) == 0)
									{
										Assertion.Fail();
									}
								}
								else
								{
									// just skip to last element
									j = assetBundle.m_assets.Count - 1;
								}
							}
							else
							{
								// just skip to last element
								i = assetBundle.m_assets.Count - 1;
							}
						}
					}
					PopItemToDo(1);
				}
				if(succeeded)
				{
					if(assets.Count > 0)
					{
						string list = "";
						int lines = 0;
						foreach(string asset in assets)
						{
							++lines;
							if(lines > 16) // HACK: hardcoded
							{
								list += "...\n";
								break;
							}
							list += string.Format("{0}\n", asset);
						}
						ETUtils.MessageBox("Add selection", string.Format("Successfully added following assets to the bundle \"{0}\":\n\n{1}({2} assets)", assetBundle.m_filename, list, assets.Count));
						if(warnAboutSceneFilenameLength)
						{
							ETUtils.MessageBox("Add selection", "Some scenes have got filenames longer than 15 symbols. This is not allowed. You'll get build-time error from the Unity pre-3.5.2. To find problematic scenes keep in mind, that they are marked with special symbol in the window");
						}
					}
					PopItemToDo(1);
				}
			}
			PopItemToDo();
		}
		
		/// <summary>
		/// Gets the amount of items to do (e.g. count of asset bundles left to be built).
		/// Do not use it explicitly, because it could be removed in future.
		/// </summary>
		/// <value>
		/// The amount of items to do.
		/// </value>
		public static int ItemsToDo
		{
			get
			{
				int ret = 0;
				foreach(int subCount in m_nItemsToDo)
				{
					ret += ((subCount > 0) ? subCount : 0);
				}
				return ret;
			}
		}
		
		#endregion
		#region Implementation
		
		private class Logger
		{
			public class BuildBrackets : IDisposable
			{
				public BuildBrackets(string format, params object[] args)
				{
					m_disposed = false;
					m_message = string.Format(format, args);
					Open();
				}
				
				public void Dispose()
				{
					Dispose(true);
					GC.SuppressFinalize(this);
				}
				
				~BuildBrackets()
				{
					Dispose(false);
				}
				
				private void Dispose(bool disposing)
				{
					if(!m_disposed)
					{
						if(disposing)
						{
							// do nothing
						}
						Close();
						m_disposed = true;
					}
				}
				
				private void Open()
				{
					Log("##teamcity[blockOpened name='{0}']", m_message);
				}
				
				private void Close()
				{
					Log("##teamcity[blockClosed name='{0}']", m_message);
				}
				
				private void Log(string format, params object[] args)
				{
					if(ETUtils.IsUnityInBatchMode())
					{
						string message = string.Format(format, args);
						Console.WriteLine(message);
					}
				}
				
				private bool m_disposed = false;
				private string m_message = null;
			}
			
			private const string NAME = "Package.AssetBundles.Builder";
		}
		
		private static void MaintainUnityEditor()
		{
			// TODO: generate event to repaint window
		}
		
		private static void PushItemToDo(params int[] subItemsCount)
		{
			m_nItemsToDo.Add((subItemsCount.Length > 0) ? subItemsCount[0] : 0);
			MaintainUnityEditor();
		}
		
		private static void PopItemToDo(params int[] subItemsCount)
		{
			int idx = m_nItemsToDo.Count - 1;
			if(idx >= 0)
			{
				if(subItemsCount.Length > 0)
				{
					m_nItemsToDo[idx] -= subItemsCount[0];
				}
				else
				{
					m_nItemsToDo.RemoveAt(idx);
				}
			}
			MaintainUnityEditor();
		}
		
		private static BuildAssetBundleOptions GetAssetBundleOptions()
		{
			return BuildAssetBundleOptions.CollectDependencies | BuildAssetBundleOptions.CompleteAssets | BuildAssetBundleOptions.DeterministicAssetBundle;
		}
		
		private static void PushDependency()
		{
			using(new Logger.BuildBrackets("BuildPipeline.PushDependencies(): {0} -> {1}", m_nDependencies, m_nDependencies + 1))
			{
				BuildPipeline.PushAssetDependencies();
				++m_nDependencies;
				using(new Logger.BuildBrackets("Depth is {0} now", m_nDependencies)) {}
			}
		}
		
		private static void PopDependency()
		{
			using(new Logger.BuildBrackets("BuildPipeline.PopDependencies(): {0} -> {1}", m_nDependencies, m_nDependencies - 1))
			{
				BuildPipeline.PopAssetDependencies();
				--m_nDependencies;
				using(new Logger.BuildBrackets("Depth is {0} now", m_nDependencies)) {}
			}
		}
		
		private static void PopAllDependencies()
		{
			while(m_nDependencies > 0)
			{
				PopDependency();
			}
		}
		
		private static string RetrieveBuildTag()
		{
			Debug.Log("RetrieveBuildTag - Started");
			string ret = null;
			if(string.IsNullOrEmpty(ret) && (BuildTagBehaviour >= BUILDTAG_USE_FROM_BM_ONLY))
			{
				// try to get from the UnityBuildSystem
				ret = InJoy.UnityBuildSystem.BuildInfo.buildTag;
			}
			if(string.IsNullOrEmpty(ret) && (BuildTagBehaviour >= BUILDTAG_DO_STAMP))
			{
				// try to think out kind of tag
				string userName = null;
				if(string.IsNullOrEmpty(userName))
				{
					try
					{
						userName = Environment.GetEnvironmentVariable("USERNAME");
					}
					catch(Exception e)
					{
						Debug.LogWarning(string.Format("RetrieveBuildTag - Caught exception: {0}", e.ToString()));
					}
				}
				if(string.IsNullOrEmpty(userName))
				{
					try
					{
						userName = Environment.GetEnvironmentVariable("USER");
					}
					catch(Exception e)
					{
						Debug.LogWarning(string.Format("RetrieveBuildTag - Caught exception: {0}", e.ToString()));
					}
				}
				if(string.IsNullOrEmpty(userName))
				{
					userName = "user";
				}
				DateTime dateTime = DateTime.Now;
				ret = string.Format("built locally by {0} in {1}", userName, dateTime);
			}
			Debug.Log("RetrieveBuildTag - Finished");
			return ret;
		}
		
		private static string GetFilledIndexFilename(string filename)
		{
			return Path.Combine(Path.GetDirectoryName(filename), ".#" + Path.GetFileNameWithoutExtension(filename) + ".cur");
		}
		
		private static string GetPrevFilledIndexFilename(string filename)
		{
			return Path.Combine(Path.GetDirectoryName(filename), ".#" + Path.GetFileNameWithoutExtension(filename) + ".bak");
		}
		
		private static void UpdateSpecifiedIndex(Index index)
		{
			using(new Logger.BuildBrackets("Update asset bundles pack \"{0}\"", (index != null) ? (index.m_filename ?? "null") : "null"))
			{
				// ensure index filename is correct
				if(string.IsNullOrEmpty(index.m_filename))
				{
					Assertion.Check(!string.IsNullOrEmpty(index.m_xmlFilename));
					if(!string.IsNullOrEmpty(index.m_xmlFilename))
					{
						if(ETUtils.DialogBox("Update asset bundles", "Index output filename is not specified. Should it be the same as an input one?"))
						{
							index.m_filename = Path.GetFileNameWithoutExtension(index.m_xmlFilename);
						}
					}
				}
				
				Debug.Log("UpdateSpecifiedIndex - Started");
				Assertion.Check(index != null, "Index source must be specified"); // SANITY CHECK
				if(index == null)
				{
					Debug.LogError("UpdateSpecifiedIndex - Index source must be specified");
					return;
				}
				
				PushItemToDo(index.m_assetBundles.Count);
				using(ETUtils.ProgressBar pb = new ETUtils.ProgressBar("Updating asset bundles", null))
				{
					int totalAssetsCount = 0;
					int checkedAssetsAmount = 0;
					foreach(Index.AssetBundle assetBundle in index.m_assetBundles)
					{
						totalAssetsCount += assetBundle.m_assets.Count;
					}
					foreach(Index.AssetBundle assetBundle in index.m_assetBundles)
					{
						using(new Logger.BuildBrackets("Update bundle \"{0}\"", assetBundle.m_filename ?? "null"))
						{
							Debug.Log(string.Format("Validating \"{0}\" ...", assetBundle.m_filename));
							int idx = 0;
							while(idx < assetBundle.m_assets.Count)
							{
								Index.AssetBundle.Asset asset = assetBundle.m_assets[idx];
								bool wasAssetRemoved = false;
								
								// display progress bar
								++checkedAssetsAmount;
								pb.Text = string.Format("Checking bundle \"{0}\", asset \"{1}\"", Path.GetFileNameWithoutExtension(assetBundle.m_filename), Path.GetFileName(asset.m_filename));
								pb.Progress = (totalAssetsCount > 0) ? (((float)checkedAssetsAmount) / totalAssetsCount) : (float)0;
								
								if(File.Exists(asset.m_filename) || Directory.Exists(asset.m_filename))
								{
									// asset with stored filename exists
									if(asset.m_guid.Equals(AssetDatabase.AssetPathToGUID(asset.m_filename)))
									{
										// OK - GUIDs are the same
										//Debug.Log(string.Format("Asset \"{0}\" is OK", asset.m_filename));
									}
									else
									{
										// file exists, however GUID differs
										string assetFilenameForGUID = AssetDatabase.GUIDToAssetPath(asset.m_guid);
										if((!string.IsNullOrEmpty(assetFilenameForGUID)) && File.Exists(assetFilenameForGUID))
										{
											// we've got two assets with mixed filenames and guids
											Debug.LogWarning(string.Format("Asset \"{0}\" and \"{1}\" are crossGUIDed", asset.m_filename, assetFilenameForGUID));
											if(ETUtils.IsUnityInBatchMode())
											{
												Debug.Log("In non-interactive mode between two crossGUIDed assets an asset with correct filename will be chosen");
												assetBundle.m_assets[idx].m_guid = AssetDatabase.AssetPathToGUID(asset.m_filename);
											}
											else if(ETUtils.DialogBox("Conflict between assets", string.Format("Asset \"{0}\" has got stored GUID from asset \"{1}\". What asset should be used?", asset.m_filename, assetFilenameForGUID), "Use second", "Use first"))
											{
												Debug.Log("Refreshing filename");
												assetBundle.m_assets[idx].m_filename = assetFilenameForGUID;
											}
											else
											{
												Debug.Log("Refreshing GUID");
												assetBundle.m_assets[idx].m_guid = AssetDatabase.AssetPathToGUID(asset.m_filename);
											}
										}
										else
										{
											// for some reason we've got old or corrupted GUID, just refresh it
											Debug.Log(string.Format("Asset \"{0}\" has got incorrect GUID, refreshing", asset.m_filename));
											assetBundle.m_assets[idx].m_guid = AssetDatabase.AssetPathToGUID(asset.m_filename);
										}
									}
									++idx;
								}
								else
								{
									// asset with stored filename doesn't exist
									string assetFilenameForGUID = AssetDatabase.GUIDToAssetPath(asset.m_guid);
									if((!string.IsNullOrEmpty(assetFilenameForGUID)) && (File.Exists(assetFilenameForGUID) || Directory.Exists(assetFilenameForGUID)))
									{
										// there is an asset for stored GUID
										Debug.LogWarning(string.Format("Asset \"{0}\" doesn't exist anymore, however there is an asset \"{1}\" with the same GUID", asset.m_filename, assetFilenameForGUID));
										if(ETUtils.IsUnityInBatchMode())
										{
											Debug.Log("In non-interactive mode missing asset will be substituted with an asset with correct GUID");
											assetBundle.m_assets[idx].m_filename = assetFilenameForGUID;
											++idx;
										}
										else if(ETUtils.DialogBox("Missing asset ", string.Format("Asset \"{0}\" doesn't exist anymore, however there is an asset \"{1}\" with the same GUID. What should be done?", asset.m_filename, assetFilenameForGUID), "Remove reference from asset bundle", "Use mentioned substitute"))
										{
											Debug.Log("Removing reference from asset bundle");
											assetBundle.m_assets.RemoveAt(idx);
											wasAssetRemoved = true;
										}
										else
										{
											Debug.Log("Substituting asset");
											assetBundle.m_assets[idx].m_filename = assetFilenameForGUID;
											++idx;
										}
									}
									else
									{
										// no asset, just remove reference from the index
										Debug.LogWarning(string.Format("Asset \"{0}\" doesn't exist, removing reference from asset bundle", asset.m_filename));
										assetBundle.m_assets.RemoveAt(idx);
										wasAssetRemoved = true;
									}
								}
								
								if(!wasAssetRemoved)
								{
									// update hash
									int j = idx - 1;
									assetBundle.m_assets[j].m_hash = File.Exists(assetBundle.m_assets[j].m_filename) ? ETUtils.CreateHashForAsset(assetBundle.m_assets[j].m_filename) : null;
								}
							}
							
							Debug.Log(string.Format("Updating \"{0}\" ...", assetBundle.m_filename));
							bool temp1;
							bool temp2;
							UpdateSpecifiedAssetBundle(assetBundle, null, out temp1, out temp2);
						}
					}
					PopItemToDo(1);
				}
				PopItemToDo(); // processed all asset bundles
				Debug.Log("UpdateSpecifiedIndex - Finished");
			}
		}
		
		private static IEnumerable<Index.AssetBundle> GetAssetBundlesList(Index index)
		{
			const string ROOT_DIRECTORY_PATH = "Assets";
			const string BACKUP_DIRECTORY_PATH = ROOT_DIRECTORY_PATH + "/.#BackedUpByAssetBundles";
			List<Index.AssetBundle> messedAssetBundles = new List<Index.AssetBundle>();
			
			// on start, lets assume, no previously backed up assets.
			// (On a side note, this could be not we actually want)
			if(Directory.Exists(BACKUP_DIRECTORY_PATH))
			{
				Directory.Delete(BACKUP_DIRECTORY_PATH, true);
			}
			
			// return asset bundles to build in their usual order
			foreach(Index.AssetBundle assetBundle in index.m_assetBundles)
			{
				if(buildMethod == BuildMethod.SubstitutingOnStubs)
				{
					// check, whether asset bundle is a special case, and then mess assets up
					List<string> containedAssets = new List<string>();
					foreach(Index.AssetBundle.Asset asset in assetBundle.m_assets)
					{
						if(File.Exists(asset.m_filename)) // i.e. not directory
						{
							containedAssets.Add(asset.m_filename);
						}
					}
					string[] allAssets = AssetDatabase.GetDependencies(containedAssets.ToArray());
					if(containedAssets.Count == allAssets.Length) // strong validation, that asset bundle is all-sufficient
					{
						// find extensions, which are substitutable
						const string SUBSTITUTE_DIRECTORY = "Assets/Packages/AssetBundles/Editor/Substitutes"; // hardcoded. TODO: search for?
						const string SUBSTITUTE_MASK = "stub{0}";
						string[] filteredFiles = Directory.GetFiles(SUBSTITUTE_DIRECTORY, string.Format(SUBSTITUTE_MASK, ".*"), SearchOption.TopDirectoryOnly);
						List<string> filteredExtensions = new List<string>();
						foreach(string filename in filteredFiles)
						{
							string extension = Path.GetExtension(filename).ToLower();
							if(!extension.Equals(".meta"))
							{
								filteredExtensions.Add(extension);
							}
						}
						
						// filter assets out
						for(int idx = containedAssets.Count - 1; idx >= 0; --idx)
						{
							string extension = Path.GetExtension(containedAssets[idx]).ToLower();
							bool substitutable = false;
							foreach(string fe in filteredExtensions)
							{
								if(extension.Equals(fe))
								{
									substitutable = true;
									break;
								}
							}
							if(!substitutable)
							{
								containedAssets.RemoveAt(idx);
							}
						}
						
						if(containedAssets.Count > 0)
						{
							// process every left file
							foreach(string srcFilename in containedAssets)
							{
								// back asset up
								string dstFilename = BACKUP_DIRECTORY_PATH + srcFilename.Substring(srcFilename.IndexOf(ROOT_DIRECTORY_PATH) + ROOT_DIRECTORY_PATH.Length);
								if(!File.Exists(dstFilename)) // to back up only once and actual asset, not stub
								{
									try
									{
										string dstDirectoryName = Path.GetDirectoryName(dstFilename);
										Directory.CreateDirectory(dstDirectoryName);
									}
									catch(Exception)
									{
									}
									File.Copy(srcFilename, dstFilename, true);
									
									// mess asset up
									string extension = Path.GetExtension(srcFilename);
									string substituteFilename = string.Format("{0}/{1}", SUBSTITUTE_DIRECTORY, string.Format(SUBSTITUTE_MASK, extension));
									File.Copy(substituteFilename, srcFilename, true);
								}
							}
							AssetDatabase.Refresh();
							
							assetBundle.m_wasAssetsSubstituted = true; // specially marks asset bundle
							messedAssetBundles.Add(assetBundle); // to build correct one later
						}
					}
				}
				
				PushDependency();
				yield return assetBundle;
				if(BuildIndependentAssetBundles)
				{
					PopDependency(); // reverts dependencies back for independent asset bundles
				}
			}
			PopAllDependencies();
			
			// restore assets
			if(Directory.Exists(BACKUP_DIRECTORY_PATH))
			{
				string[] files = Directory.GetFiles(BACKUP_DIRECTORY_PATH, "*.*", SearchOption.AllDirectories);
				if((files != null) && (files.Length > 0))
				{
					foreach(string srcFilename in files)
					{
						string dstFilename = srcFilename.Replace(BACKUP_DIRECTORY_PATH, ROOT_DIRECTORY_PATH);
						File.Copy(srcFilename, dstFilename, true);
					}
					AssetDatabase.Refresh();
				}
				Directory.Delete(BACKUP_DIRECTORY_PATH, true);
			}
			
			// return asset bundles to re-build w/ correct assets
			foreach(Index.AssetBundle assetBundle in messedAssetBundles)
			{
				// free unused memory
				using(new Logger.BuildBrackets("Unload unused assets"))
				{
					EditorUtility.UnloadUnusedAssetsIgnoreManagedReferences();
				}
				
				PushDependency();
				yield return assetBundle;
				PopDependency();
			}
			PopAllDependencies();
			
			yield break;
		}

        private static bool IsAssetBundleCompressed(Index.AssetBundle assetBundle)
        {
            bool ret = (OverrideAssetBundlesCompression == AssetBundlesCompressionOverriding.Compressed);
            bool suppressUncompressedAssetBundles = ((!RTUtils.UncompressedAssetBundlesAllowed));
            // HACK: instead of assetBundle.m_isCompressed
            bool isCompressed = assetBundle.m_isCompressed.HasValue ? assetBundle.m_isCompressed.Value : suppressUncompressedAssetBundles;
            ret |= (isCompressed && (OverrideAssetBundlesCompression == AssetBundlesCompressionOverriding.DoNotOverride));
            if (suppressUncompressedAssetBundles)
            {
                ret = true;
            }
            return ret;
        }
		
		private static void BuildSpecifiedIndex(Index index, string pathOutput, BuildTarget buildTarget, BuildOptions buildOptions)
		{
			using(new Logger.BuildBrackets("Build asset bundles pack \"{0}\"", (index != null) ? (index.m_filename ?? "null") : "null"))
			{
				Debug.Log("BuildSpecifiedIndex - Started");
				
				// check input
				Assertion.Check(index != null, "Index source must be specified"); // SANITY CHECK
				if(index == null)
				{
					Debug.LogError("BuildSpecifiedIndex - Index source must be specified");
					return;
				}
				Assertion.Check(!string.IsNullOrEmpty(pathOutput), "Path should be specified");
				if(string.IsNullOrEmpty(pathOutput))
				{
					Debug.LogError("BuildSpecifiedIndex - Wrong input parameters");
					return;
				}
				
				using(ETUtils.ProgressBar pb = new ETUtils.ProgressBar("Building asset bundles", null))
				{
					// create required subfolders
					Debug.Log("BuildSpecifiedIndex - Creating output folder");
					ETUtils.CreateDirectory(pathOutput);
					
					// check, whether assets are valid (exists, moved, deleted)
					UpdateSpecifiedIndex(index);
					
					// generate asset bundles
					Index genIndex = Index.DuplicateInstance(index);
					genIndex.m_xmlFilename = GetPrevFilledIndexFilename(index.m_xmlFilename);
					Debug.Log("BuildSpecifiedIndex - Adding assets to asset bundles");
					bool areAllAssetBundlesCompressed = true;
					try
					{
						PushItemToDo(genIndex.m_assetBundles.Count);
						Index realIndex = Analyzer.ReorganizeDistribution(genIndex);
						foreach(Index.AssetBundle assetBundle in GetAssetBundlesList(genIndex))
						{
							using(new Logger.BuildBrackets("Build bundle \"{0}\"", assetBundle.m_filename ?? "null"))
							{
								List<string> strAssets = new List<string>();
								strAssets.Clear();
								for(int idx = 0; idx < assetBundle.m_assets.Count; ++idx)
								{
									string assetFilename = assetBundle.m_assets[idx].m_filename;
									if(File.Exists(assetFilename))
									{
										strAssets.Add(assetFilename);
									}
									else
									{
										// if file doesn't exist, then it can be directory only
										Assertion.Check(Directory.Exists(assetFilename));
									}
								}
								if(strAssets.Count > 0) // skip empty asset bundles
								{
									// fill index with corresponding data
									string contentChecksum = "";
									foreach(Index.AssetBundle.Asset asset in assetBundle.m_assets)
									{
										if(!Directory.Exists(asset.m_filename))
										{
											asset.m_hash = ETUtils.CreateHashForAsset(asset.m_filename);
											contentChecksum += asset.m_hash;
										}
									}
									assetBundle.m_contentHash = Analyzer.ComputeAssetBundleHashDependingOnProvidedDistribution(realIndex, assetBundle) ?? ETUtils.CreateHashForString(contentChecksum);
									
									// build asset bundle
									string fakeRelativeFilename = string.Format("{0}{1}", assetBundle.m_filename, kAssetBundleFileExtension);
									string fakeAbsoluteFilename = ETUtils.CombinePaths(pathOutput, fakeRelativeFilename);
									string relativeFilename = string.Format("{0}_{1}{2}", assetBundle.m_filename, assetBundle.m_contentHash, kAssetBundleFileExtension);
									string absoluteFilename = ETUtils.CombinePaths(pathOutput, relativeFilename);
									
									// ensure, directory exists and file does not
									ETUtils.CreateDirectoryForFile(absoluteFilename);
									ETUtils.DeleteFile(absoluteFilename);

                                    bool isCompressed = false;

									switch(assetBundle.m_type)
									{
									case Index.AssetBundle.Type.None:
										Debug.LogWarning(string.Format("Asset bundle \"{0}\" has got type \"empty\". Skipped", assetBundle.m_filename));
										throw new UnityException("Internal error of class: unpredictable behaviour");
									case Index.AssetBundle.Type.Asset:
										List<UnityEngine.Object> objAssets = new List<UnityEngine.Object>();
										List<string> fnameAssets = new List<string>();
										objAssets.Clear();
										fnameAssets.Clear();
										using(new Logger.BuildBrackets("Collect objects for asset bundle \"{0}\"", assetBundle.m_filename ?? "null"))
										{
											for(int idx = 0; idx < strAssets.Count; ++idx)
											{
												objAssets.Add(AssetDatabase.LoadMainAssetAtPath(strAssets[idx]));
												fnameAssets.Add(strAssets[idx].ToLower());
											}
										}
										using(new Logger.BuildBrackets("BuildPipeline.BuildAssetBundle(\"{0}\")", assetBundle.m_filename ?? "null"))
										{
											if(IsAssetBundleCompressed(assetBundle))
											{
                                                isCompressed = true;
#if UNITY_3_5
												BuildPipeline.BuildAssetBundleExplicitAssetNames(objAssets.ToArray(), fnameAssets.ToArray(), fakeAbsoluteFilename, GetAssetBundleOptions(), buildTarget, buildOptions);
#else // UNITY_4_x
												BuildPipeline.BuildAssetBundleExplicitAssetNames(objAssets.ToArray(), fnameAssets.ToArray(), fakeAbsoluteFilename, GetAssetBundleOptions(), buildTarget);
#endif
											}
											else
											{
												areAllAssetBundlesCompressed = false;
#if UNITY_3_5
												BuildPipeline.BuildAssetBundleExplicitAssetNames(objAssets.ToArray(), fnameAssets.ToArray(), fakeAbsoluteFilename, GetAssetBundleOptions(), buildTarget, buildOptions | BuildOptions.UncompressedAssetBundle);
#else // UNITY_4_x
												BuildPipeline.BuildAssetBundleExplicitAssetNames(objAssets.ToArray(), fnameAssets.ToArray(), fakeAbsoluteFilename, GetAssetBundleOptions() | BuildAssetBundleOptions.UncompressedAssetBundle, buildTarget);
#endif
											}
										}
										break;
									case Index.AssetBundle.Type.Scene:
										using(new Logger.BuildBrackets("BuildPipeline.BuildSceneBundle(\"{0}\")", assetBundle.m_filename ?? "null"))
										{
											if(IsAssetBundleCompressed(assetBundle))
											{
                                                isCompressed = true;

												BuildPipeline.BuildStreamedSceneAssetBundle(strAssets.ToArray(), fakeAbsoluteFilename, buildTarget);
											}
											else
											{
												areAllAssetBundlesCompressed = false;
												BuildPipeline.BuildPlayer(strAssets.ToArray(), fakeAbsoluteFilename, buildTarget, buildOptions | BuildOptions.BuildAdditionalStreamedScenes | BuildOptions.UncompressedAssetBundle);
											}
										}
										break;
									default:
										Debug.LogError("Internal error of class: unpredictable behaviour");
										throw new UnityException("Internal error of class: unpredictable behaviour");
									}
									
									if(!assetBundle.m_wasAssetsSubstituted)
									{
										// rename built asset bundle with correct name
										File.Move(fakeAbsoluteFilename, absoluteFilename);

                                        //remember uncompressed
                                        if (!isCompressed)
                                        {
                                            uncompressedBundleList.Add(Path.GetFileName(absoluteFilename));
                                        }
										
										// fill index with newly gained data
										assetBundle.m_size         = new FileInfo(absoluteFilename).Length;
										assetBundle.m_urls         = new string[] {"./" + relativeFilename};
									}
									else
									{
										// remove built asset bundle, because it is contained stubs
										File.Delete(fakeAbsoluteFilename);
										
										// reset information about asset bundle
										assetBundle.m_contentHash = null;
										assetBundle.m_size = null;
										assetBundle.m_urls = null;
										assetBundle.m_wasAssetsSubstituted = false; // reverts specially marked asset bundle
									}
								}
								else
								{
									// asset bundle is empty, it should be excluded from the index _later_
									assetBundle.m_assets.Clear(); // makes asset bundle literally empty
									Debug.LogWarning(string.Format("AssetBundle \"{0}\" doesn't contain anything. Skipped", assetBundle.m_filename));
								}
								
								PopItemToDo(1); // processed one asset bundle
							}
						}
						
						// remove empty asset bundles from the list _here_
						for(int idxAssetBundle = 0; idxAssetBundle < genIndex.m_assetBundles.Count; ++ idxAssetBundle)
						{
							if(genIndex.m_assetBundles[idxAssetBundle].m_assets.Count == 0)
							{
								genIndex.m_assetBundles.RemoveAt(idxAssetBundle);
								--idxAssetBundle;
							}
						}
					}
					finally
					{
						// whether buildings were successfull or not
						// all made dependencies must be reverted back
						// otherwise next attempt to build asset bundle will be screwed
						PopAllDependencies();
						
						PopItemToDo(); // processed all asset bundles
					}
					
					// index is ready at this point, save it
					try
					{
						PushItemToDo(1);
						Debug.Log("BuildSpecifiedIndex - Adding index file for asset bundles");
						
						genIndex.m_buildTag = RetrieveBuildTag();
						Debug.Log(string.Format("BuildSpecifiedIndex - Stamped build tag \"{0}\"", genIndex.m_buildTag ?? "null"));
						
						string indexChecksum = "";
						foreach(Index.AssetBundle assetBundle in genIndex.m_assetBundles)
						{
							Assertion.Check(!string.IsNullOrEmpty(assetBundle.m_contentHash));
							indexChecksum += assetBundle.m_contentHash;
						}
						indexChecksum = ETUtils.CreateHashForString(indexChecksum);
						string genIndexFilename = genIndex.m_filename;
						if(!string.IsNullOrEmpty(Index.m_overridenFilenameMask))
						{
							genIndexFilename = string.Format(Index.m_overridenFilenameMask, genIndexFilename);
						}
						string fakeUabFilename = ETUtils.CombinePaths(pathOutput, genIndexFilename + kAssetBundleFileExtension);
						string uabFilename = ETUtils.CombinePaths(pathOutput, genIndexFilename + "_" + indexChecksum + kAssetBundleFileExtension);
						string verFilename = ETUtils.CombinePaths(pathOutput, genIndexFilename + ".version");
						
						// ensure, directory exists and file does not
						ETUtils.CreateDirectoryForFile(uabFilename);
						ETUtils.DeleteFile(uabFilename); // remove old one
						
						// save just calculated hash to version file
						using(StreamWriter sw = new StreamWriter(verFilename))
						{
							sw.WriteLine(indexChecksum);
						}
						
						// temporary save index to file in the project
						ETUtils.CreateDirectoryForFile(kGeneratedIndexFilename);
						using(FileStream fs = new FileStream(kGeneratedIndexFilename, FileMode.Create))
						{
							genIndex.SaveInstance(fs);
						}
						AssetDatabase.Refresh(); // make Unity find out just generated index
						
						// create asset bundle, which would contain generated index as a main asset
						PushDependency();
						using(new Logger.BuildBrackets("BuildPipeline.BuildAssetBundle(\"{0}\")", genIndexFilename))
						{
							if(areAllAssetBundlesCompressed)
							{
#if UNITY_3_5
								BuildPipeline.BuildAssetBundle(AssetDatabase.LoadMainAssetAtPath(kGeneratedIndexFilename), null, fakeUabFilename, GetAssetBundleOptions(), buildTarget, buildOptions);
#else // UNITY_4_x
								BuildPipeline.BuildAssetBundle(AssetDatabase.LoadMainAssetAtPath(kGeneratedIndexFilename), null, fakeUabFilename, GetAssetBundleOptions(), buildTarget);
#endif
							}
							else
							{
#if UNITY_3_5
								BuildPipeline.BuildAssetBundle(AssetDatabase.LoadMainAssetAtPath(kGeneratedIndexFilename), null, fakeUabFilename, GetAssetBundleOptions(), buildTarget, buildOptions | BuildOptions.UncompressedAssetBundle);
#else // UNITY_4_x
								BuildPipeline.BuildAssetBundle(AssetDatabase.LoadMainAssetAtPath(kGeneratedIndexFilename), null, fakeUabFilename, GetAssetBundleOptions() | BuildAssetBundleOptions.UncompressedAssetBundle, buildTarget);
#endif
							}
						}
						PopDependency();
						
						// rename built asset bundle with correct name
						File.Move(fakeUabFilename, uabFilename);
						
						if(BuildReadableIndex)
						{
							// copy index file to output folder (in case somebody would like to look into it)
							string xmlFilename = ETUtils.CombinePaths(pathOutput, ".#" + Path.GetFileNameWithoutExtension(verFilename) + ".dbg.xml");
							File.Copy(kGeneratedIndexFilename, xmlFilename, true);
						}
						
						// index to compare with arrived
						index.m_indexToCompareWith = genIndex;
						if(!ETUtils.IsUnityInBatchMode())
						{
							// update every index
							// - current index (plain distribution only)
							string strippedIndexFilename = index.m_xmlFilename;
							Index strippedIndex = Index.DuplicateAndStripInstance(index);
							using(FileStream stream = new FileStream(strippedIndexFilename, FileMode.Create))
							{
								strippedIndex.SaveInstance(stream);
							}
							// - current index filled with data
							string filledIndex = GetFilledIndexFilename(index.m_xmlFilename);
							genIndex.m_strippedIndexHash = ETUtils.CreateHashForFile(strippedIndexFilename);
							using(FileStream fs = new FileStream(filledIndex, FileMode.Create))
							{
								genIndex.SaveInstance(fs);
							}
							// - previous index filled with data
							File.Copy(filledIndex, GetPrevFilledIndexFilename(index.m_xmlFilename), true);
						}
						
						// remove generated index from the project
						ETUtils.DeleteFile(kGeneratedIndexFilename);
						ETUtils.DeleteFile(AssetDatabase.GetTextMetaDataPathFromAssetPath(kGeneratedIndexFilename));
						AssetDatabase.Refresh(); // make Unity forget about generated files
					}
					finally
					{
						// whether buildings were successfull or not
						// all made dependencies must be reverted back
						// otherwise next attempt to build asset bundle will be screwed
						PopAllDependencies();
						
						PopItemToDo(); // processed index
					}
					
					// if asset bundles have been generated to the project folder, import them
					if(pathOutput.ToLower().Contains(Application.dataPath.ToLower()))
					{
						AssetDatabase.Refresh();
					}
				}
				Debug.Log("BuildSpecifiedIndex - Finished");
			}
		}
		
		private const string kAssetBundleFileExtension = ".unity3d";
		private const string kGeneratedIndexFilename   = TARGET_IN_STREAMING_ASSETS + "/index.xml";
		private static bool m_buildIndependentAssetBundles = false;
		private static BuildMethod m_buildMethod = BuildMethod.StraightForward;
		private static bool m_buildReadableIndex = false;
		private static int m_nBuildTagBehaviour = BUILDTAG_USE_FROM_BM_ONLY;
		private static AssetBundlesCompressionOverriding m_compressionOverriding = AssetBundlesCompressionOverriding.DoNotOverride;
		private static int m_nDependencies = 0;
		private static Index m_index = null;
		private static List<int> m_nItemsToDo = new List<int>();
        public static List<string> uncompressedBundleList = new List<string>();  //remeber which bundles are compressed.
        #endregion
	}
}
